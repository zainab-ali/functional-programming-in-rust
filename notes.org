* What's the point of FP?
Slide: Why? Understandable code.
We want code that's easy to understand.
There are lots of ways we achieve this:
 - naming things.
 - structuring
 - writing tests
functional programming is a technique of breaking down our problems to help us reason about the code we write.
* Agenda
Slide:
 - Design a basic app
 - Hunt for a bug
 - Rewrite our app with FP techniques

Slide: Techniques
 - Pure functions
 - Identifying side effects
 - Modelling data
 - Total functions

Our goal is to get an intuition for reasoning with functional programming.

We'll explore these with an example.
* Example: birthday app
Slide:

./birthday 2000-08-06
Happy birthday! Congratulations on becoming 24!

./birthday 2000-08-08
It's not your birthday yet. Wait for 2 more days.

./birthday 2000-08-05
You've already had your birthday. I hope you had fun!

Slide:
code

* Problems

./birthday 2030-08-06
panic!

./birthday 2000-02-29
panic!, but not this year

We're going to solve these later.

* Questions: why might we get this bug?

Slide:

./birthday 2000-08-06 # around midnight on the 5th August
It's not your birthday yet. Wait for 0 more days.


Let's go back to the code.
We've assumed this is a constant value, but =today()= could change each time we call it.

* Pure functions
Slide:
 - Can be substituted with its result.
 - No other behaviour, aside from returning its output

Working with pure functions and data (values) is easier purely because they don't change.
They're also easy to test.

There are other things that are pure - reading from the environment.
It's somewhat subjective, but easier to understand if we don't do it.

* Rewriting the code

Getting the current day will always be impure, but some of our other functions don't need to be.

If we extract out the value of today, and put it at the top, it now no longer changes. And this fixes our bug!

There are other values that aren't exactly obvious to reason about. Where is the birthday coming from?

It comes from the arguments. We can extract it to a separate function.

We now have a few functions that don't have side effects:
 - age
 - days_until_birthday
 - birthday

And ones that do
 - date_arg
 - today
   
In rewriting our code in this way, we're already applying some functional programming principles.

We've rewritten age to be a pure function. There are some additional benefits.
 - If under test age(foo, bar) gives 42, it will do so when we run it. No exceptions.
 - We can read through the code, and assume that its the case.

A pure function is one that will always return the same output given the same input.
The function call can be substituted for its result.

* Splitting out even more side effects
It would be nice to test what message we choose to display.
Instead of printing, we're going to return some data.
Modeling data:
 - Using immutable datastructures. In this case, enum
 - Another final side effect is printing.
   We can separate this from the rest of the code through the use of ADT.
 - This is a common pattern.
   We're going to add a new function calc_message() that returns a Message enum.
 - 
We've separated the pure and side-effecting parts.
We do so by modelling data. Our data represents how we act on it.
Modelling data is a big concern in FP. A lot of code boils down to pattern matching.

* Recap
 Side effects:
  - reading
  - getting the current date
  - printing
 Pure code:
  - calc_message
* The benefits
 - Easy to reason about
   My code is the result of calc_message(myinput, date)
   And I can write a test for it.
 - We can now split our code into several parts: pure parts, and impure parts.
 The pure parts are much easier to reason about.
 For example, I know that if I call this with X and Y, I should get Z
  It doesn't matter what my implementation is.
  I can write tests to make sure the implementation is correct.
* Problems

./birthday 2030-08-06
panic!

./birthday 2000-02-29
panic!, but not this year

./birthday tomorrow
panic!

 - Totality.
   For all possible combinations of inputs, I should get a valid output.
 - Is that the case? No! For example:
    - If I call this with a birthday less than today.
      If I was born on a leap year, and this year is non-leap.
      If I don't pass in a valid date.
 - Defining pure functions helps us think about these cases and write tests for them.
    
* How to handle errors
This depends entirely on your business problem.
 - You may want to panic.
   Or you may want to have special handling.
 We want leap years to be part of our logic.
* Dealing with errors 
Future dates are incorrect.

 - Equational reasoning
 - Handling errors
 - Algebraic data types
